# BSL Grammar Parser - Архитектурное решение

> ⚠️ **ВНИМАНИЕ: Этот документ устарел!**  
> Актуальное решение: использовать **tree-sitter** вместо logos+nom  
> См. [CURRENT_DECISIONS.md](./CURRENT_DECISIONS.md) и [roadmap.md](../roadmap.md)

**Дата:** 2025-07-30  
**Статус:** ~~Утверждено~~ **УСТАРЕЛ**  
**Версия:** 1.0

## Цель документа

Зафиксировать архитектурные решения по реализации BSL Grammar Parser для обнаружения несуществующих конструкций языка 1С, генерируемых LLM.

## Контекст и требования

### Основная задача
Интеграция с LLM-агентами (типа Claude) для итеративной разработки с проверкой кода:
- Агент генерирует BSL код
- Запускает `bsl-analyzer syntaxcheck`
- Получает структурированный список ошибок
- Исправляет код и повторяет процесс

### Ключевые требования
1. **Быстрый холодный старт** - частые вызовы CLI
2. **Машиночитаемый вывод** - JSON для агентов
3. **Человекочитаемый вывод** - для разработчиков и IDE
4. **Минимальный размер бинарника**
5. **Интеграция с существующим UnifiedBslIndex**

## Архитектурное решение

### Выбор библиотеки парсера

**Решение:** `logos` + `nom`

**Обоснование:**
- ✅ Уже используется в проекте (см. `src/parser/lexer.rs`)
- ✅ Максимальная производительность (2ms на файл 1000 строк)
- ✅ Поддержка инкрементального парсинга
- ✅ Полный контроль над AST
- ✅ Минимальный overhead для CLI

**Альтернативы рассмотрены:**
- `chumsky` - отличные сообщения об ошибках, но медленнее (5-8ms)
- `pest` - проще в освоении, но медленнее и меньше контроля
- `tree-sitter` - избыточен для задачи проверки типов

### Архитектура вывода ошибок

#### Единое внутреннее представление
```rust
#[derive(Debug, Clone, Serialize)]
pub struct Diagnostic {
    pub severity: Severity,
    pub location: Location,
    pub code: String,        // "BSL001", "BSL002"
    pub message: String,
    pub details: DiagnosticDetails,
    pub suggestions: Vec<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(tag = "type")]
enum DiagnosticDetails {
    UnknownMethod {
        object: String,
        method: String,
    },
    UnknownType {
        type_name: String,
    },
    WrongArgumentCount {
        expected: usize,
        found: usize,
    },
}
```

#### Форматы вывода

1. **JSON** (по умолчанию для pipe/redirect)
```json
{
  "diagnostics": [{
    "severity": "error",
    "location": {
      "file": "file.bsl",
      "range": {
        "start": {"line": 5, "column": 8},
        "end": {"line": 5, "column": 22}
      }
    },
    "code": "BSL001",
    "message": "Unknown method",
    "details": {
      "type": "UnknownMethod",
      "object": "Массив",
      "method": "ДобавитьЭлемент"
    },
    "suggestions": ["Добавить", "Вставить"]
  }]
}
```

2. **Human-readable** (для терминала)
```
error[BSL001]: Unknown method 'ДобавитьЭлемент' for type 'Массив'
  --> file.bsl:5:8
   |
 5 |   Массив.ДобавитьЭлемент(значение);
   |          ^^^^^^^^^^^^^^^ method not found
   |
   = help: did you mean one of these?
     - Добавить
     - Вставить
```

3. **LSP** (для IDE интеграции)
4. **SARIF** (для CI/CD)

### CLI интерфейс

```bash
# Основное использование
bsl-analyzer syntaxcheck <file> [options]

# Параметры
--format <format>    # json|human|lsp|sarif|compact (auto-detect по умолчанию)
--config <path>      # Путь к конфигурации для UnifiedBslIndex
--platform <version> # Версия платформы 1С (по умолчанию из кеша)

# Примеры
bsl-analyzer syntaxcheck module.bsl --format json
bsl-analyzer syntaxcheck src/*.bsl --config ./config --platform 8.3.25
```

### Автоопределение формата
```rust
fn detect_output_format() -> OutputFormat {
    // Pipe или redirect -> JSON
    if !std::io::stdout().is_terminal() {
        return OutputFormat::Json;
    }
    
    // Запуск из IDE -> LSP
    if std::env::var("BSL_LSP_MODE").is_ok() {
        return OutputFormat::Lsp;
    }
    
    // Иначе -> человеческий формат
    OutputFormat::Human
}
```

## План реализации

### Фаза 1: Минимальный парсер (MVP)
1. Расширить существующий lexer для полной токенизации BSL
2. Реализовать парсер основных конструкций:
   - Вызовы методов (`Объект.Метод()`)
   - Обращения к свойствам (`Объект.Свойство`)
   - Создание объектов (`Новый Тип()`)
   - Глобальные функции (`Сообщить()`)
3. Интеграция с UnifiedBslIndex для валидации

### Фаза 2: Форматтеры вывода
1. Реализовать DiagnosticEngine
2. Создать форматтеры для каждого типа вывода
3. Добавить автоопределение формата

### Фаза 3: CLI команда
1. Добавить команду `syntaxcheck` в CLI
2. Интегрировать с системой кеширования проекта
3. Добавить batch-обработку файлов

### Фаза 4: Расширенная функциональность
1. Поддержка инкрементального парсинга
2. Проверка сигнатур методов
3. Контекстно-зависимые проверки

## Метрики успеха

1. **Производительность:** < 5ms на файл 1000 строк
2. **Холодный старт:** < 50ms
3. **Размер бинарника:** прирост < 2MB
4. **Точность:** 100% обнаружение несуществующих методов/типов
5. **UX:** Агенты могут использовать без дополнительной настройки

## Риски и митигация

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Сложность полной грамматики BSL | Высокая | Среднее | Начать с подмножества для MVP |
| Производительность валидации | Средняя | Высокое | Кеширование результатов проверок |
| Поддержка всех конструкций | Высокая | Низкое | Итеративное добавление |

## Решение утверждено

- **Библиотека парсера:** logos + nom
- **Архитектура вывода:** Универсальная с форматтерами
- **Приоритет:** CLI для LLM-агентов

## Связанные документы

- [BSL Grammar Development Guide](BSL_GRAMMAR_DEVELOPMENT.md) - Руководство по разработке грамматики и адаптации ANTLR

---

*Документ будет обновляться по мере реализации и получения обратной связи.*