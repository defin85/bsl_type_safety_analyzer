# Roadmap реализации LSP для системы типов 1С

## Цель проекта

Создать полноценный LSP сервер для 1С:Предприятие с корректной поддержкой системы типов, ориентированный в первую очередь на использование LLM (Language Models) для генерации и анализа кода.

### Почему это критично для LLM

1. **LLM не знает особенностей 1С** - модель может предложить `Новый СправочникМенеджер`, не понимая, что это невозможно
2. **Нет обратной связи** - LLM не может проверить правильность своего кода
3. **Контекстная слепота** - модель не понимает, что `Соответствие["ключ"]` и элемент в `Для Каждого` - разные типы
4. **Галлюцинации типов** - LLM может придумать несуществующие методы

## Принципы реализации

- **НЕ упрощаем архитектуру** - полная поддержка всех особенностей
- **Фасеты обязательны** - правильное представление множественных форм
- **Контекст критичен** - разные подсказки в разных ситуациях
- **Источники данных** - и синтаксис-помощник, и Configuration.xml

## Фаза 0: Подготовка инфраструктуры ✅ (Завершено)

### Что сделано:
- ✅ Архитектура "Unified Type System with Facets"
- ✅ Парсинг синтаксис-помощника (HBK archives)
- ✅ Парсинг Configuration.xml
- ✅ Система кеширования (platform_cache + project_cache)
- ✅ UnifiedBslIndex с поиском типов

### Результат:
- Есть доступ к 4000+ платформенным типам
- Можем извлечь структуру конфигурации
- Кеширование работает

## Фаза 1: Базовое автодополнение (2-3 недели)

### Цели:
- Показывать правильные методы после точки
- НЕ показывать менеджеры после "Новый"
- Базовая фильтрация по контексту

### Задачи:

#### 1.1 Интеграция UnifiedBslIndex с LSP (3-4 дня)
```rust
// Подключить индекс к LSP серверу
impl LanguageServer {
    async fn completion(&self, params: CompletionParams) -> Vec<CompletionItem> {
        let context = self.detect_context(&params);
        self.unified_index.get_completions(context)
    }
}
```

#### 1.2 Детектор контекста (2-3 дня)
```rust
enum CompletionContext {
    AfterDot(String),      // После точки от объекта
    AfterNew,              // После ключевого слова "Новый"
    EmptyLine,             // Начало строки
    GlobalScope,           // Глобальный контекст
}
```

#### 1.3 Фильтрация по AccessRules (2-3 дня)
- can_construct → показывать после "Новый"
- is_global_property → показывать в глобальном контексте
- is_iteration_element → НЕ показывать в обычном автодополнении

#### 1.4 Базовые тесты (3-4 дня)
- Тест: после "Новый" нет менеджеров
- Тест: после "Справочники." есть список справочников
- Тест: глобальные функции доступны в пустом контексте

### Метрики успеха:
- ✅ Автодополнение работает для 70% базовых случаев
- ✅ Нет явно неправильных подсказок (менеджеры после Новый)
- ✅ Скорость отклика < 100ms

## Фаза 2: Контекстное автодополнение (1-2 месяца)

### Цели:
- Определение типа переменных
- Правильные фасеты в зависимости от контекста
- Поддержка цепочек вызовов

### Задачи:

#### 2.1 Type Inference Engine (2 недели)
```rust
struct TypeInferenceEngine {
    // Отслеживание типов переменных в скоупе
    variable_types: HashMap<String, TypeInfo>,
    
    // Определение типа выражения
    fn infer_type(&mut self, expr: &Expression) -> Option<TypeInfo>
}
```

#### 2.2 Активация правильных фасетов (1 неделя)
```rust
// После Справочники. → manager facet
// После СоздатьЭлемент() → object facet
// После НайтиПоКоду() → reference facet
```

#### 2.3 Поддержка цепочек вызовов (1 неделя)
```rust
// Справочники.Контрагенты.СоздатьЭлемент().Записать()
//     ↓           ↓              ↓            ↓
//  global    manager facet   object facet   method
```

#### 2.4 Обработка циклов Для Каждого (1 неделя)
```rust
// Определение iteration_type для переменной цикла
if let ForEachLoop { collection, variable } = statement {
    let collection_type = self.infer_type(collection);
    let element_type = self.get_iteration_type(collection_type);
    self.variable_types.insert(variable, element_type);
}
```

#### 2.5 Cross-facet методы (1 неделя)
```rust
// Контрагент.Метаданные() → переход от reference к metadata facet
```

### Метрики успеха:
- ✅ Правильное определение типа в 80% случаев
- ✅ Корректные подсказки для разных фасетов
- ✅ Поддержка циклов и итераций

## Фаза 3: Продвинутый анализ (3+ месяца)

### Цели:
- Множественные конструкторы
- Типизированные элементы коллекций
- Динамический доступ (частично)
- Проверка совместимости типов

### Задачи:

#### 3.1 Множественные конструкторы (2 недели)
```rust
// Новый Массив vs Новый Массив(10) vs Новый Массив(10, 5)
// Подсказки с правильными сигнатурами
```

#### 3.2 Контекстно-зависимые типы коллекций (2 недели)
```rust
// Соответствие["ключ"] → Произвольный
// Для Каждого Элем Из Соответствие → КлючИЗначение
```

#### 3.3 Базовая поддержка динамического доступа (3 недели)
```rust
// Справочники[ИмяПеременной] - попытка определить значение
// Если ИмяПеременной = "Контрагенты" выше по коду
```

#### 3.4 Type Checker (3 недели)
```rust
struct TypeChecker {
    // Проверка совместимости типов
    fn is_assignable(&self, from: &TypeInfo, to: &TypeInfo) -> bool
    
    // Проверка параметров методов
    fn check_method_call(&self, method: &Method, args: &[Expression]) -> Vec<Diagnostic>
}
```

#### 3.5 Диагностики типов (2 недели)
- Несовместимые присваивания
- Неправильные параметры методов
- Попытка создать неконструируемый тип

### Метрики успеха:
- ✅ Поддержка всех основных паттернов 1С
- ✅ Диагностики помогают избежать ошибок типов
- ✅ LLM получает корректную обратную связь

## Фаза 4: Интеграция с LLM (1 месяц)

### Цели:
- Специальный API для LLM
- Объяснение ошибок типов
- Контекстные подсказки

### Задачи:

#### 4.1 LLM-friendly API
```rust
struct LLMAssistant {
    // Почему этот код неправильный?
    fn explain_error(&self, code: &str) -> String
    
    // Какие методы доступны в этом контексте?
    fn get_available_methods(&self, context: &str) -> Vec<MethodInfo>
    
    // Правильно ли используется тип?
    fn validate_type_usage(&self, code: &str) -> ValidationResult
}
```

#### 4.2 Расширенные диагностики для LLM
```rust
enum DiagnosticForLLM {
    CannotConstruct {
        type_name: String,
        reason: String,
        suggestion: String,
    },
    WrongFacet {
        expected: String,
        actual: String,
        how_to_fix: String,
    },
}
```

### Метрики успеха:
- ✅ LLM не генерирует невалидный код
- ✅ Ошибки объясняются понятно
- ✅ Подсказки помогают исправить код

## Риски и митигация

### Риск 1: Сложность превысит возможности
**Митигация**: Каждая фаза даёт рабочий результат, можно остановиться

### Риск 2: Производительность
**Митигация**: Агрессивное кеширование, инкрементальный анализ

### Риск 3: Неполнота данных о типах
**Митигация**: Фоллбеки, эвристики, "лучше что-то, чем ничего"

## Ключевые метрики проекта

1. **Корректность** > Полнота
   - Лучше не показать, чем показать неправильно

2. **Скорость отклика** < 100ms
   - Для интерактивного использования

3. **Покрытие сценариев** > 80%
   - Основные паттерны должны работать

4. **LLM Success Rate** > 90%
   - Код, сгенерированный LLM с нашими подсказками, должен компилироваться

## Технологический стек

- **Rust** - для производительности
- **tower-lsp** - LSP framework
- **UnifiedBslIndex** - наша система типов
- **tree-sitter** - парсер BSL (в перспективе)

## Вывод

Проект амбициозный, но выполнимый. Ключ к успеху:
1. Не упрощать архитектуру - иначе теряется смысл
2. Итеративная разработка - каждая фаза даёт результат
3. Фокус на LLM - это основной пользователь
4. Метрики и тестирование - чтобы не деградировать

**Estimated Time**: 6-8 месяцев для полной реализации
**MVP (Фаза 1-2)**: 2-3 месяца