# BSL Type Safety Analyzer - Требования v2.0

**Дата:** 2025-08-01  
**Статус:** На основе критического анализа  
**Версия:** 2.0

## Резюме

Документ содержит пересмотренные требования к BSL Type Safety Analyzer на основе критического анализа текущей архитектуры. Фокус смещён с over-engineering решений на практическую пользу для разработчиков 1С.

## 1. Основные принципы

### 1.1 Простота превыше всего
- **НЕ** создавать абстракции "на будущее"
- **НЕ** оптимизировать то, что работает достаточно быстро
- **НЕ** кешировать всё подряд

### 1.2 Фокус на реальных проблемах
- Критические ошибки runtime > стилистические замечания
- Быстрый feedback > полный анализ
- Практичность > академическая корректность

### 1.3 Производительность там, где важно
- Старт анализатора < 50ms
- Анализ файла < 100ms
- Память < 50MB для типичного использования

## 2. Архитектурные требования

### 2.1 Отказ от UnifiedBslIndex

**Проблема:** Монолитный God Object с загрузкой всего в память

**Решение:** Lazy Loading архитектура
```rust
pub struct BslTypeSystem {
    // Компактный индекс (что есть)
    type_index: TypeIndex,        // 2-3MB
    
    // Данные на диске (mmap или db)
    type_storage: TypeStorage,    // доступ по требованию
    
    // Горячий кеш
    hot_cache: LruCache<TypeId, TypeInfo>,  // 100 записей max
}
```

### 2.2 Модульная архитектура вместо монолита

```
bsl-analyzer/
├── core/           # Минимальное ядро
│   ├── parser/     # BSL parser (tree-sitter)
│   └── types/      # Type system (lazy)
├── rules/          # Подключаемые правила
│   ├── critical/   # Ошибки runtime
│   ├── quality/    # Code quality
│   └── style/      # Стилистика
└── frontends/      # Разные интерфейсы
    ├── cli/        # Командная строка
    ├── lsp/        # Language Server
    └── mcp/        # MCP сервер (опционально)
```

### 2.3 Инкрементальность by design

- Анализ только изменённых файлов
- Кеш на уровне файлов, не всей конфигурации
- Параллельный анализ независимых модулей

## 3. Функциональные требования

### 3.1 BSL Parser - приоритет #1

**Требования:**
- Использовать tree-sitter или аналог
- Поддержка рус/eng синтаксиса
- Устойчивость к синтаксическим ошибкам
- Инкрементальный парсинг

**НЕ требования:**
- Полное соответствие грамматике 1С
- Парсинг препроцессора (можно игнорировать)

### 3.2 Анализ типов - только критичное

**Проверять:**
1. Вызовы несуществующих методов
2. Обращения к несуществующим свойствам
3. Неправильное количество параметров
4. Явные ошибки типов (число вместо строки)

**НЕ проверять:**
1. "Возможные" null reference (слишком много false positives)
2. Неиспользуемые переменные (не критично)
3. Стиль кода (есть другие инструменты)

### 3.3 Эвристики для динамического языка

```bsl
// Паттерн 1: Условная инициализация
Объект = Неопределено;
Если Условие Тогда
    Объект = СоздатьОбъект();
КонецЕсли;
Объект.Метод(); // НЕ ошибка в контексте 1С
```

**Требование:** Распознавать типичные паттерны 1С и не генерировать ложные срабатывания

## 4. Нефункциональные требования

### 4.1 Производительность

| Метрика | Требование | Обоснование |
|---------|------------|-------------|
| Холодный старт | < 50ms | CLI использование |
| Анализ файла 1000 строк | < 100ms | Отзывчивость |
| Память (idle) | < 10MB | LSP сервер |
| Память (активная) | < 50MB | Множественные проекты |

### 4.2 Простота использования

```bash
# Минимальная конфигурация
bsl-analyzer check file.bsl

# Результат понятен без документации
Ошибка: Метод "ДобавитьЭлемент" не существует
  --> file.bsl:10:8
   |
10 | Массив.ДобавитьЭлемент(значение);
   |        ^^^^^^^^^^^^^^^ возможно вы имели в виду "Добавить"
```

### 4.3 Интеграция

- **CLI first** - основной способ использования
- **LSP** - базовая поддержка (ошибки, не автодополнение)
- **MCP** - только если есть реальная польза

## 5. Антитребования (чего НЕ делать)

### 5.1 НЕ создавать всеобъемлющий индекс
- Платформа меняется раз в полгода
- Конфигурация анализируется по частям
- 99% типов не используются в конкретном файле

### 5.2 НЕ изобретать велосипеды
- Использовать tree-sitter для парсинга
- SQLite для хранения метаданных
- LSP библиотеки для интеграции

### 5.3 НЕ оптимизировать преждевременно
- HashMap для 24K элементов не нужен
- Кеширование платформы экономит 200ms раз в полгода
- Граф наследования - overengineering

## 6. Метрики успеха

### 6.1 Для разработчиков
- Находит реальные ошибки (> 90% точность)
- Быстрый feedback (< 1 сек на файл)
- Легко интегрируется в workflow

### 6.2 Для проекта
- Простой код (< 10K LOC core)
- Легко добавлять правила
- Сообщество может контрибьютить

## 7. План миграции

### Фаза 1: MVP (1 месяц)
1. Tree-sitter parser для BSL
2. 10-20 критических правил
3. CLI интерфейс
4. Базовые тесты

### Фаза 2: Расширение (2 месяца)
1. LSP сервер (только диагностика)
2. Больше правил (до 50)
3. Интеграционные тесты
4. Документация

### Фаза 3: Полировка (1 месяц)
1. Оптимизация производительности
2. Улучшение UX
3. CI/CD интеграция

## 8. Примеры правильной архитектуры

### rust-analyzer
- Инкрементальность через salsa
- Lazy loading зависимостей
- Минимальный memory footprint

### TypeScript compiler
- Файл-ориентированный анализ
- Эффективный type resolver
- Практичные эвристики

### gopls
- Быстрый старт
- Малое потребление памяти
- Фокус на полезных features

## Заключение

Текущая архитектура BSL Type Safety Analyzer страдает от over-engineering и преждевременной оптимизации. Данные требования направлены на создание практичного инструмента, который решает реальные проблемы разработчиков 1С, а не демонстрирует архитектурные паттерны.

**Главное:** Работающий анализатор с 20 правилами полезнее идеальной архитектуры без анализа.

---

*Документ создан на основе критического анализа проекта и лучших практик индустрии.*